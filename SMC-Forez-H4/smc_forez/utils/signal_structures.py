"""
Standardized signal data structures for SMC Forez
Ensures consistency across all components
"""
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Union
from enum import Enum

# Import the actual enums - will need to handle import properly in __init__.py
try:
    from ..signals.signal_generator import SignalType, SignalStrength
except ImportError:
    # Define minimal local enums for type checking if imports fail
    class SignalType(Enum):
        BUY = "BUY"
        SELL = "SELL"
        WAIT = "WAIT"
    
    class SignalStrength(Enum):
        WEAK = "WEAK"
        MODERATE = "MODERATE"
        STRONG = "STRONG"
        VERY_STRONG = "VERY_STRONG"


@dataclass
class EntryDetails:
    """Standardized entry details structure"""
    entry_price: float = 0.0
    stop_loss: float = 0.0
    take_profit: float = 0.0
    risk_reward_ratio: float = 0.0
    setup_type: str = "pullback"  # pullback, breakout, reversal
    confluence_factors: List[str] = field(default_factory=list)


@dataclass
class SignalRecommendation:
    """Standardized recommendation structure used across all components"""
    # Core signal data
    action: SignalType = SignalType.WAIT
    confidence: str = "LOW"  # LOW, MODERATE, HIGH
    entry_timeframe: str = "M15"
    
    # Strength and scoring
    strength_factors: List[str] = field(default_factory=list)
    strength_score: float = 0.0
    confluence_score: float = 0.0
    
    # Entry execution details
    entry_details: EntryDetails = field(default_factory=EntryDetails)
    
    # Market context
    trend_direction: str = "CONSOLIDATION"
    setup_type: str = "pullback"
    
    # Validation flags
    is_valid: bool = False
    trend_aligned: bool = False
    signal_confluence: bool = False
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for legacy compatibility"""
        return {
            'action': self.action,
            'confidence': self.confidence,
            'entry_timeframe': self.entry_timeframe,
            'strength_factors': self.strength_factors,
            'strength_score': self.strength_score,
            'confluence_score': self.confluence_score,
            'entry_details': {
                'entry_price': self.entry_details.entry_price,
                'stop_loss': self.entry_details.stop_loss,
                'take_profit': self.entry_details.take_profit,
                'risk_reward_ratio': self.entry_details.risk_reward_ratio,
                'setup_type': self.entry_details.setup_type,
                'confluence_factors': self.entry_details.confluence_factors
            },
            'trend_direction': self.trend_direction,
            'setup_type': self.setup_type,
            'is_valid': self.is_valid,
            'trend_aligned': self.trend_aligned,
            'signal_confluence': self.signal_confluence
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'SignalRecommendation':
        """Create from dictionary"""
        entry_details_dict = data.get('entry_details', {})
        entry_details = EntryDetails(
            entry_price=entry_details_dict.get('entry_price', 0.0),
            stop_loss=entry_details_dict.get('stop_loss', 0.0),
            take_profit=entry_details_dict.get('take_profit', 0.0),
            risk_reward_ratio=entry_details_dict.get('risk_reward_ratio', 0.0),
            setup_type=entry_details_dict.get('setup_type', 'pullback'),
            confluence_factors=entry_details_dict.get('confluence_factors', [])
        )
        
        return cls(
            action=data.get('action', SignalType.WAIT),
            confidence=data.get('confidence', 'LOW'),
            entry_timeframe=data.get('entry_timeframe', 'M15'),
            strength_factors=data.get('strength_factors', []),
            strength_score=data.get('strength_score', 0.0),
            confluence_score=data.get('confluence_score', 0.0),
            entry_details=entry_details,
            trend_direction=data.get('trend_direction', 'CONSOLIDATION'),
            setup_type=data.get('setup_type', 'pullback'),
            is_valid=data.get('is_valid', False),
            trend_aligned=data.get('trend_aligned', False),
            signal_confluence=data.get('signal_confluence', False)
        )


@dataclass
class QualityFilterInput:
    """Standardized input structure for quality filter"""
    symbol: str
    signal_type: str  # "buy", "sell", "wait"
    entry_price: float
    stop_loss: float
    take_profit: float
    risk_reward_ratio: float
    recommendation_confidence: str  # LOW, MODERATE, HIGH
    analysis: Dict = field(default_factory=dict)


def create_quality_filter_input(opportunity: Dict) -> Dict:
    """
    Creates the standardized input for the quality filter directly from an
    'opportunity' dictionary generated by the SMCAnalyzer.
    """
    symbol = opportunity.get('symbol', 'UNKNOWN')
    recommendation = opportunity.get('recommendation', {})
    entry_details = recommendation.get('entry_details', {})
    decision_details = opportunity.get('decision_details', {})

    # This structure now perfectly matches what EnhancedSignalQualityFilter expects
    return {
        'symbol': symbol,
        'signal_type': normalize_action_string(recommendation.get('action', 'WAIT')),
        'entry_price': entry_details.get('entry_price', 0),
        'stop_loss': entry_details.get('stop_loss', 0),
        'take_profit': entry_details.get('take_profit', 0),
        'risk_reward_ratio': entry_details.get('risk_reward_ratio', 0),
        'recommendation_confidence': recommendation.get('confidence', 'LOW'),
        'analysis': {
            'confluence_score': recommendation.get('confluence_score', 0),
            'strength_factors': recommendation.get('strength_factors', []),
            'trend_alignment': recommendation.get('trend_aligned', False),
            'signal_confluence': recommendation.get('signal_confluence', False),
            'timeframe_agreement': decision_details.get('timeframe_agreement_score', 0.5),
            'trend_confidence': decision_details.get('trend_confidence_score', 0.5)
        }
    }


def create_quality_filter_input_legacy(symbol: str, rec_data: Dict, 
                                     analysis_data: Optional[Dict] = None) -> Dict:
    """Create quality filter input from legacy recommendation format"""
    entry_details = rec_data.get('entry_details', {})
    
    # Enhanced to ensure all expected fields are present
    analysis = analysis_data or {}
    
    # Extract actual confluence score from signal_confluence data if available
    signal_confluence = rec_data.get('signal_confluence', {})
    
    # CRITICAL FIX: Handle case where signal_confluence is boolean instead of dict
    if isinstance(signal_confluence, bool):
        # If it's a boolean, create empty signal scores
        signal_scores = {'buy': 0, 'sell': 0, 'wait': 0}
    elif isinstance(signal_confluence, dict):
        # If it's a dict, extract signal_scores safely
        signal_scores = signal_confluence.get('signal_scores', {'buy': 0, 'sell': 0, 'wait': 0})
    else:
        # Fallback for any other type
        signal_scores = {'buy': 0, 'sell': 0, 'wait': 0}
    
    # Calculate total confluence score from signal scores (this is what shows in logs as total score)
    total_confluence_score = max(signal_scores.get('buy', 0), signal_scores.get('sell', 0))
    
    # Fallback to direct confluence_score if signal_confluence approach doesn't work
    if total_confluence_score == 0:
        total_confluence_score = rec_data.get('confluence_score', 0)
    
    # Ensure all required analysis fields
    required_analysis_fields = {
        'confluence_score': total_confluence_score,  # Use calculated total score
        'strength_factors': rec_data.get('strength_factors', []),
        'trend_alignment': rec_data.get('trend_aligned', False),
        'signal_confluence': signal_confluence if isinstance(signal_confluence, dict) else {'has_confluence': bool(signal_confluence)},
        'timeframe_agreement': 1.0 if rec_data.get('strength_score', 0) >= 3 else 0.5,
        'trend_confidence': _calculate_trend_confidence(rec_data)  # FIXED: Use enhanced confidence calculation
    }
    
    # Merge with provided analysis data
    final_analysis = {**analysis, **required_analysis_fields}
    
    return {
        'symbol': symbol,
        'signal_type': normalize_action_string(rec_data.get('action', 'WAIT')),
        'entry_price': entry_details.get('entry_price', 0),
        'stop_loss': entry_details.get('stop_loss', 0),
        'take_profit': entry_details.get('take_profit', 0),
        'risk_reward_ratio': entry_details.get('risk_reward_ratio', 0),
        'recommendation_confidence': rec_data.get('confidence', 'LOW'),
        'market_bias': rec_data.get('market_bias', 'NEUTRAL'),  # CRITICAL FIX: Include market bias
        'confluence_score': total_confluence_score,  # CRITICAL FIX: Include confluence score at signal level
        'signal_confluence': signal_confluence,  # CRITICAL FIX: Include signal confluence data at signal level
        'strength_factors': rec_data.get('strength_factors', []),  # CRITICAL FIX: Include strength factors at signal level
        'confidence': rec_data.get('confidence', 'LOW'),  # CRITICAL FIX: Include confidence at signal level for quality filter
        'analysis': final_analysis
    }


def _calculate_trend_confidence(rec_data: Dict) -> float:
    """Calculate trend confidence from recommendation data with enhanced logic"""
    # First, check for confidence_score (0.0-1.0 scale)
    confidence_score = rec_data.get('confidence_score', 0)
    if confidence_score > 0:
        # If we have a confidence_score, use it directly (it's already 0.0-1.0)
        if confidence_score > 1.0:
            confidence_score = confidence_score / 100.0  # Convert percentage to decimal
        return min(confidence_score, 1.0)  # Cap at 1.0
    
    # Fallback to string confidence mapping
    confidence_str = rec_data.get('confidence', 'LOW')
    if confidence_str in ['HIGH', 'MODERATE', 'MEDIUM']:  # FIXED: Include MEDIUM
        return 0.8
    elif confidence_str in ['LOW']:
        return 0.5
    else:
        return 0.3  # For WAIT, INVALID, etc.


def normalize_action_string(action: Union[SignalType, str]) -> str:
    """Normalize action to lowercase string format"""
    if hasattr(action, 'value'):  # Handle any enum with .value attribute
        return action.value.lower()
    elif isinstance(action, str):
        # Handle both 'SIGNALTYPE.BUY' and 'buy' formats
        action_str = action.lower()
        if '.' in action_str:
            action_str = action_str.split('.')[-1]  # Get the part after the dot
        return action_str
    else:
        return 'wait'


def normalize_action_enum(action: Union[SignalType, str]) -> SignalType:
    """Normalize action to SignalType enum"""
    if isinstance(action, SignalType):
        return action
    elif isinstance(action, str):
        action_str = action.upper()
        if '.' in action_str:
            action_str = action_str.split('.')[-1]  # Get the part after the dot
        
        try:
            return SignalType[action_str]
        except (KeyError, AttributeError):
            return SignalType.WAIT
    else:
        return SignalType.WAIT


def normalize_strength_string(strength: Union[SignalStrength, str]) -> str:
    """Normalize strength to uppercase string format"""
    if hasattr(strength, 'value'):  # Handle any enum with .value attribute
        return strength.value.upper()
    elif isinstance(strength, str):
        strength_str = strength.upper()
        if '.' in strength_str:
            strength_str = strength_str.split('.')[-1]  # Get the part after the dot
        return strength_str
    else:
        return 'WEAK'